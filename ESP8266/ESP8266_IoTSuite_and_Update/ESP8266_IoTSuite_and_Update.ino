// Generated by Vorto from vorto.private.joaopedro.bastos.ESP8266completo:1.0.0

#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>
#include <PubSubClient.h>
#include <ESP8266WiFi.h>

//########################################
//Bibliotecas para Update + ESP8266WiFi.h
#include <ESP8266HTTPClient.h>
#include <ESP8266httpUpdate.h>
#include <Arduino_JSON.h>

#define USE_SECURE_CONNECTION 1

#if (USE_SECURE_CONNECTION == 1)
#include <WiFiClientSecure.h>
#endif

Adafruit_BME280 bme;

#include "src/model/functionblock/Temperature.h"
#include "src/model/functionblock/Humidity.h"
#include "src/model/functionblock/Illuminance.h"
#include "src/model/infomodel/ESP8266completo.h"

/**************************************************************************/
/* Configuration section, adjust to your settings                         */
/**************************************************************************/

//#define tenantId "t6246773985cc4d95816d9bc53ceb61c5_hub"
#define tenantId "t5f7ed5ae8357493c914ff61b8287a3e9_hub"

/* MQTT broker endpoint */
const char* hub_adapter_host = "mqtt.bosch-iot-hub.com";

#if (USE_SECURE_CONNECTION == 1)
/* SHA-1 fingerprint of the server certificate of the MQTT broker, UPPERCASE and spacing */
const char* mqttServerFingerprint = "<00 B6 42 DA A5 6F 5A 9F F3 B3 7E 50 90 58 32 4C 47 61 18 D5>";
#endif

/* Define the period of data transmission in ms */
#define MQTT_DATA_PERIOD 300000

/* Define the buffer size for payload strings */
#define MQTT_MAX_SIZE  50

/* Device Configuration */
//String deviceId = "joao.ESP8266.SFP:esp8266_completo";
String deviceId = "joao.Tese.Devices:ESP8266_as_Gateway";
//String authId = "joao.ESP8266.SFP_esp8266_completo";
String authId = "joao.Tese.Devices_ESP8266_as_Gateway";
const char* device_password = "Tartaruga5*";

/* Payload Configuration*/
//String ditto_topic = "joao.ESP8266.SFP/esp8266_completo";
String ditto_topic = "joao.Tese.Devices/ESP8266_as_Gateway";

/* WiFi Configuration */
const char* ssid = "DESKTOP-C6SOVQS 6152";
const char* password = "12345678";

/* BEGIN SAMPLE CODE */
/* dummy numeric */
long dummy_value = 0;

/* Sample text value */
char msg[MQTT_MAX_SIZE];
/* END SAMPLE CODE */

/**************************************************************************/
/* Implementation                                                         */
/**************************************************************************/

/* Port on which the MQTT broker is listening */
#if (USE_SECURE_CONNECTION == 1)
#define MQTT_SERVER_PORT 8883
#else
#define MQTT_SERVER_PORT 1883
#endif

/* Topic on which the telemetry data is published */
String telemetryTopic = String("telemetry/") + String(tenantId) + String("/");

/* This variables stores the client ID in the MQTT protocol */
String clientId;

/* Timestamp of previous data transmission */
long lastMqttMsg;

/* Setup WiFi mqttClient and MQTT mqttClient */
#if (USE_SECURE_CONNECTION == 1)
WiFiClientSecure wifiClient;
#else
WiFiClient wifiClient;
#endif

PubSubClient mqttClient(wifiClient);

/* The information model object */
vorto_private_joaopedro_bastos::ESP8266completo infoModel;
org_eclipse_vorto_types::SensorValue value;

//###########################################################################################################################
//Variáveis para Update

//Your Domain name with URL path or IP address with path
const char* host_roll = "device.eu1.bosch-iot-rollouts.com";
const char* fingerprint_roll = "BE A7 9A 85 9D C9 1A CF 91 5F CF E5 13 27 F5 3F 0B B1 63 51";
String serverName = "https://device.eu1.bosch-iot-rollouts.com/D60F7F26-9AFC-4FFB-8FA5-00A6FC6D774A/controller/v1/esp8266_01";

// the following variables are unsigned longs because the time, measured in
// milliseconds, will quickly become a bigger number than can be stored in an int.
unsigned long lastTime = 0;
// Set timer to 20 minutes
unsigned long timerDelay = 1200000;

String links_1;
int httpResponseCode_1;
int httpResponseCode_2;
String id_str;

/**************************************************************************/
/* Function to connect to the WiFi network                                */
/**************************************************************************/
void setup_wifi() {

  delay(10);

  /* We start by connecting to a WiFi network */
  Serial.print("Connecting to WiFi with SSID: ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);

  /* Wait for succesful connection, hang if there is none? */
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
  }

  randomSeed(micros());

  Serial.println("");
  Serial.println("WiFi connected");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  Serial.print("MAC address: ");
  Serial.println(WiFi.macAddress());
  Serial.println(" ");
}

/**************************************************************************/
/* Function called when data on a subscribed topic arrives                */
/**************************************************************************/
void mqttDataReceived(char* mqttTopic, byte* mqttPayload, unsigned int mqttLength) {

  Serial.println("joao");

  String reqTopic = (String) mqttTopic;
  reqTopic.toLowerCase();

  /* If this is a 'switch' command, flip the lights */
  if (reqTopic.startsWith("command") && reqTopic.endsWith("test")) {
    String newState;
    Serial.println("Switch command received, switching ...");

    newState = "Alive";

    /* parse Bosch IoT Hub's message ID for response */
    String messageId = reqTopic.substring(reqTopic.indexOf("req/") + 4);
    messageId = messageId.substring(0, messageId.indexOf("/"));

    /* if this is a 2-way command, respond */
    if (messageId != "") {
      /*Serial.println("Sender expects reply, responding to message with ID: " + messageId);*/

      /* create MQTT response topic */
      String resTopic = ("command///res/" + messageId + "/200").c_str();

      /* parse Bosch IoT Things correlation ID for response*/
      String reqPayload = (String) (char*) mqttPayload;

      /* 17 is the length of 'correlation-id' and subsequent '":"' */
      String correlationId;
      correlationId = reqPayload.substring(reqPayload.indexOf("correlation-id") + 17);

      String correlationId2;
      correlationId2 = correlationId;
      correlationId.remove(correlationId2.indexOf('"'));

      Serial.println("Sender expects reply, responding to message with Correlation-Id: " + correlationId);
      Serial.println();

      /* create Ditto compliant MQTT response payload */
      String resPayload = "{\"topic\":\"" + ditto_topic + "/things/live/messages/switch\",";
      resPayload += "\"headers\":{\"correlation-id\":\"" + correlationId + "\",";
      resPayload += "\"version\":2,\"content-type\":\"text/plain\"},";
      resPayload += "\"path\":\"/inbox/messages/switch\",";
      resPayload += "\"value\":\"" + newState + "\",";
      resPayload += "\"status\": 200 }";

      mqttClient.publish(resTopic.c_str(), resPayload.c_str());
    }
  }
}

/**************************************************************************/
/* Reconnect to MQTT broker in case the connection dropped                */
/**************************************************************************/
void reconnect() {
  String username = String(authId) + "@" + String(tenantId);
  /* Loop while not connected */
  while (!mqttClient.connected()) {

    /* If connected to the MQTT broker... */
    if (mqttClient.connect(clientId.c_str(), username.c_str(), device_password)) {
      /* Attempt to Connect succesfull */
      Serial.println("Successfully connected to MQTT Broker\n");
      /* SAMPLE CODE */
      String topic = "command/+/+/req/#";
      mqttClient.subscribe(topic.c_str());
      /* END SAMPLE CODE */
    } else {
      /* otherwise wait for 5 seconds before retrying */
      Serial.println("Waiting for next attempt to connect to MQTT Broker");
      delay(5000);
    }
  }
}

/**************************************************************************/
/* Functions for publishing data using MQTT					              */
/**************************************************************************/

boolean publishTemperature() {
  String mqttPayload = infoModel.temperature.serialize(ditto_topic , deviceId, "temperature");

  /* Debug output on console */
  Serial.print("Publishing Payload for temperature: ");
  Serial.print(mqttPayload);
  Serial.print(" to topic: ");
  Serial.println(telemetryTopic);

  /* Publish all available temperature data to the MQTT broker */
  if (!mqttClient.publish(telemetryTopic.c_str(), mqttPayload.c_str())) {
    Serial.println("Publish temperature failed, if this happens repeatedly increase MQTT_MAX_PACKET_SIZE in PubSubClient.h");
    return false;
  } else {
    return true;
  }
}
boolean publishHumidity() {
  String mqttPayload = infoModel.humidity.serialize(ditto_topic , deviceId, "humidity");

  /* Debug output on console */
  Serial.print("Publishing Payload for humidity: ");
  Serial.print(mqttPayload);
  Serial.print(" to topic: ");
  Serial.println(telemetryTopic);

  /* Publish all available humidity data to the MQTT broker */
  if (!mqttClient.publish(telemetryTopic.c_str(), mqttPayload.c_str())) {
    Serial.println("Publish humidity failed, if this happens repeatedly increase MQTT_MAX_PACKET_SIZE in PubSubClient.h");
    return false;
  } else {
    return true;
  }
}
boolean publishIlluminance() {
  String mqttPayload = infoModel.illuminance.serialize(ditto_topic , deviceId, "illuminance");

  /* Debug output on console */
  Serial.print("Publishing Payload for illuminance: ");
  Serial.print(mqttPayload);
  Serial.print(" to topic: ");
  Serial.print(telemetryTopic);
  Serial.println("\n");

  /* Publish all available illuminance data to the MQTT broker */
  if (!mqttClient.publish(telemetryTopic.c_str(), mqttPayload.c_str())) {
    Serial.println("Publish illuminance failed, if this happens repeatedly increase MQTT_MAX_PACKET_SIZE in PubSubClient.h");
    return false;
  } else {
    return true;
  }
}

//###########################################################################
//Funções para Update

String Poll_for_Updates(String serverName) {

  HTTPClient http;

  // Your IP address with path or Domain name with URL path
  http.begin(wifiClient, serverName);
  http.addHeader("Accept", "application/hal+json");
  http.addHeader("Authorization", "TargetToken 16873cd42738d484f3436de00906f5e2");

  // Send HTTP POST request
  httpResponseCode_1 = http.GET();

  String pollUpdates = "{}";
  String url_information = "{}";

  if (httpResponseCode_1 == 200) {
    Serial.print("HTTP Response code: ");
    Serial.println(httpResponseCode_1);
    pollUpdates = http.getString();

    JSONVar updates = JSON.parse(pollUpdates);
    Serial.println(updates);

    // myObject.keys() can be used to get an array of all the keys in the object
    JSONVar keys_1 = updates.keys();
    JSONVar links = updates[keys_1[1]];
    JSONVar keys_2 = links.keys();
    JSONVar deploymentBase = links[keys_2[0]];
    links_1 = keys_2[0];
    JSONVar keys_3 = deploymentBase.keys();
    JSONVar href = deploymentBase[keys_3[0]];
    Serial.print(keys_3[0]);
    Serial.print(" = ");
    Serial.println(href);
    url_information = JSON.stringify(href);
    url_information.trim();
    url_information = url_information.substring(1, url_information.length() - 1);
  }
  else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode_1);
  }

  // Free resources
  http.end();

  return url_information;
}

String Get_Information(String url_information) {

  HTTPClient http;

  // Your IP address with path or Domain name with URL path
  http.begin(wifiClient, url_information);
  http.addHeader("Accept", "application/hal+json");
  http.addHeader("Authorization", "TargetToken 16873cd42738d484f3436de00906f5e2");

  // Send HTTP POST request
  httpResponseCode_2 = http.GET();

  String getInformation = "{}";
  String url_download = "{}";

  if (httpResponseCode_2 == 200) {
    Serial.print("HTTP Response code: ");
    Serial.println(httpResponseCode_2);
    getInformation = http.getString();

    JSONVar information = JSON.parse(getInformation);
    Serial.println(information);

    // myObject.keys() can be used to get an array of all the keys in the object
    JSONVar chaves = information.keys();
    JSONVar id = information[chaves[0]];
    id_str = JSON.stringify(id);
    id_str.trim();
    id_str = id_str.substring(1, id_str.length() - 1);
    Serial.print("Id = ");
    Serial.println(id_str);
    JSONVar deployment = information[chaves[1]];
    JSONVar chaves2 = deployment.keys();
    JSONVar chunks = deployment[chaves2[2]];
    JSONVar chaves3 = chunks[0].keys();
    JSONVar artifacts = chunks[0][chaves3[3]];
    JSONVar chaves4 = artifacts[0].keys();
    JSONVar links_2 = artifacts[0][chaves4[3]];
    JSONVar chaves5 = links_2.keys();
    JSONVar download = links_2[chaves5[0]];
    JSONVar chaves6 = download.keys();
    JSONVar href_2 = download[chaves6[0]];
    Serial.print(chaves6[0]);
    Serial.print(" = ");
    Serial.println(href_2);

    //Converter JSONVar em String
    url_download = JSON.stringify(href_2);
    url_download.trim();
    url_download = url_download.substring(1, url_download.length() - 1);
  }
  else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode_2);
  }

  // Free resources
  http.end();

  return url_download;
}

void httpPOSTRequest(String feedback_url, String id) {

  HTTPClient http;

  // Your IP address with path or Domain name with URL path
  http.begin(wifiClient, feedback_url);
  http.addHeader("Content-Type", "application/json;charset=UTF-8");
  http.addHeader("Accept", "application/hal+json");
  http.addHeader("Authorization", "TargetToken 16873cd42738d484f3436de00906f5e2");

  // Send HTTP POST request
  String data = ("{\"id\":\"" + id + "\",\"status\":{\"result\":{\"finished\":\"success\"},\"execution\":\"closed\",\"details\":[ ]}}");
  int httpResponseCode_3 = http.POST(data);

  if (httpResponseCode_3 == 200) {
    Serial.print("HTTP Response code: ");
    Serial.println(httpResponseCode_3);
    Serial.println("Feedback enviado!");
  }
  else {
    Serial.print("Error code: ");
    Serial.println(httpResponseCode_3);
  }

  // Free resources
  http.end();
}

void Download_and_Update_Sketch(String url_download) {
  // Cria instância de Cliente seguro
  WiFiClientSecure client;
  client.setInsecure();

  String feedback_url = "https://device.eu1.bosch-iot-rollouts.com/D60F7F26-9AFC-4FFB-8FA5-00A6FC6D774A/controller/v1/esp8266_01/deploymentBase/" + id_str + "/feedback";

  // Atualização Sketch ---------------------------------
  Serial.println("*** Atualização do sketch ***");
  for (byte b = 5; b > 0; b--) {
    Serial.print(b);
    Serial.println("... ");
    delay(1000);
  }

  // Efetua atualização do Sketch
  t_httpUpdate_return resultado = ESPhttpUpdate.update(client, url_download);

  // Verifica resultado
  switch (resultado) {
    case HTTP_UPDATE_FAILED: {
        String s = ESPhttpUpdate.getLastErrorString();
        Serial.println("\nFalha: " + s);
      } break;
    case HTTP_UPDATE_NO_UPDATES:
      Serial.println("\nNenhuma atualização disponível");
      break;
    case HTTP_UPDATE_OK: {
        Serial.println("\nSucesso, reiniciando...");
        httpPOSTRequest(feedback_url, id_str);
        ESP.restart();
      } break;
  }
}
//##################################################################################

/**************************************************************************/
/* Arduino Setup and Loop Functions							              */
/**************************************************************************/
void setup() {
  Serial.begin(115200);

  setup_wifi();

  int min_humid = 0;
  int max_humid = 100;
  unsigned status;

  // default settings
  // (you can also pass in a Wire library object like &Wire2)
  status = bme.begin(0x76);
  if (!status) {
    Serial.println("Could not find a valid BME280 sensor, check wiring, address, sensor ID!");
    while (1);
  }

  /* Create a MQTT client ID */
  clientId = deviceId;

  Serial.print("Device ID: ");
  Serial.println(clientId);
  Serial.println(" ");

  /* Add the device ID to the telemetry topic as the final element */
  telemetryTopic += deviceId;

  /* Configure the MQTT client with the server and callback data */
  mqttClient.setServer(hub_adapter_host, MQTT_SERVER_PORT);
  mqttClient.setCallback(mqttDataReceived);

#if (USE_SECURE_CONNECTION == 1)
  wifiClient.setInsecure();
  if (!wifiClient.connect(hub_adapter_host, MQTT_SERVER_PORT)) {
    Serial.println("Secure connection failed, restart Device");
    ESP.restart();
  } else {
    Serial.println("Successfully established secure connection to broker");
  }

  if (!wifiClient.verify(mqttServerFingerprint, hub_adapter_host)) {
    Serial.println("Verification failed, restart Device");
    ESP.restart();
  } else {
    Serial.println("Successfully verified server certificate");
  }
#endif

  /*Test MQQT Client*/
  mqttClient.publish("", "");

  //Temperature
  infoModel.temperature.setunit("ºC");

  //Humidade
  infoModel.humidity.setminRangeValue(min_humid);
  infoModel.humidity.setmaxRangeValue(max_humid);
  infoModel.humidity.setminMeasuredValue(infoModel.humidity.getmaxRangeValue());
  infoModel.humidity.setsensorUnits("%");

  //Luminosidade
  value.setminMeasured(1024.0);

  //############################################################################
  // Definições para ESP8266
  // LED indicador de progresso
  ESPhttpUpdate.setLedPin(LED_BUILTIN, LOW);

  // Callback - Início
  ESPhttpUpdate.onStart([] {
    Serial.println("Atualização iniciada (callback)");
  });

  // Callback - Fim
  ESPhttpUpdate.onEnd([] {
    Serial.println("Atualização concluída (callback)");
  });

  // Callback - Erro
  ESPhttpUpdate.onError([](int erro) {
    Serial.println("Erro na atualização (callback), código: " + String(erro));
  });

  // Callback - Progresso
  ESPhttpUpdate.onProgress([](size_t progresso, size_t total) {
    Serial.print(progresso * 100 / total);
    Serial.print(" ");
  });

  // Não reiniciar automaticamente
  ESPhttpUpdate.rebootOnUpdate(false);
}

void loop() {
  /* Check if connection to MQTT broker is still good */
  if (!mqttClient.connected()) {
    /* Reconnect if not */
    reconnect();
  }

  /* Event handling of the MQTT client */
  mqttClient.loop();

  /* Publish the telemetry data periodically */
  long now = millis();
  if (now - lastMqttMsg > MQTT_DATA_PERIOD) {

    float temp = bme.readTemperature();

    float humid = bme.readHumidity();

    float luz = analogRead(A0);
    delay(3);

    luz = (luz / 1024.0) * 100;

    lastMqttMsg = now;

    /* SAMPLE CODE */
    dummy_value++;
    snprintf(msg, MQTT_MAX_SIZE - 1, "hello world #%ld", dummy_value);

    //Temperatura
    infoModel.temperature.setvalue(temp);

    //Humidade
    infoModel.humidity.setsensorValue(humid);

    /* minimum value measured since last reboot */
    if (humid < infoModel.humidity.getminMeasuredValue()) {
      infoModel.humidity.setminMeasuredValue(humid);
    };
    /* maximum value measured since last reboot */
    if (humid > infoModel.humidity.getmaxMeasuredValue()) {
      infoModel.humidity.setmaxMeasuredValue(humid);
    };

    //Luminosidade
    value.setcurrentMeasured(luz);
    /* minimum value measured since last reboot */
    if (luz < value.getminMeasured()) {
      value.setminMeasured(luz);
    };
    /* maximum value measured since last reboot */
    if (luz > value.getmaxMeasured()) {
      value.setmaxMeasured(luz);
    };
    infoModel.illuminance.setvalue(value);

    //Status Properties

    publishTemperature();
    publishHumidity();
    publishIlluminance();
    /* END OF SAMPLE CODE */
  }

  //##############################################################
  //Loop para Update

  if ((millis() - lastTime) > timerDelay) {
    //Check WiFi connection status
    if (WiFi.status() == WL_CONNECTED) {

#if (USE_SECURE_CONNECTION == 1)
      wifiClient.setInsecure();
      if (!wifiClient.connect(host_roll, 443)) {
        Serial.println("Secure connection failed, restart Device");
        ESP.restart();
      } else {
        Serial.println("Successfully established secure connection to Rollouts");
      }

      if (!wifiClient.verify(fingerprint_roll, host_roll)) {
        Serial.println("Verification failed, restart Device");
        ESP.restart();
      } else {
        Serial.println("Successfully verified server certificate");
      }
#endif

      String url_information = Poll_for_Updates(serverName);

      if (httpResponseCode_1 == 200 && links_1 == "deploymentBase") {
        String url_download = Get_Information(url_information);

        if (httpResponseCode_2 == 200) {
          Download_and_Update_Sketch(url_download);
        }
        else {
          return;
        }
      }
      else {
        Serial.println("No updates available!\n");
        lastTime = millis();
      }
    }
    else {
      Serial.println("WiFi Disconnected");
    }
    lastTime = millis();
  }
}
