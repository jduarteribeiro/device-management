// Generated by Vorto from vorto.private.joaopedro.bastos.ESP8266completo:1.0.0

#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>

Adafruit_BME280 bme;

#define Botao D5
#define LED_AQ D8
#define LED_Estado D6
#define LED D3

#define USE_SECURE_CONNECTION 1

#include <PubSubClient.h>
#include <ESP8266WiFi.h>
#if (USE_SECURE_CONNECTION == 1)
    #include <WiFiClientSecure.h>
#endif
#include "src/model/functionblock/Temperature.h"
#include "src/model/functionblock/Humidity.h"
#include "src/model/functionblock/Illuminance.h"
#include "src/model/functionblock/LocalControlState.h"
#include "src/model/infomodel/ESP8266completo.h"

/**************************************************************************/
/* Configuration section, adjust to your settings                         */
/**************************************************************************/

#define tenantId "t6246773985cc4d95816d9bc53ceb61c5_hub"

/* MQTT broker endpoint */
const char* hub_adapter_host = "mqtt.bosch-iot-hub.com";

#if (USE_SECURE_CONNECTION == 1)
	/* SHA-1 fingerprint of the server certificate of the MQTT broker, UPPERCASE and spacing */
	const char* mqttServerFingerprint = "<00 B6 42 DA A5 6F 5A 9F F3 B3 7E 50 90 58 32 4C 47 61 18 D5>";
#endif

/* Define the period of data transmission in ms */
#define MQTT_DATA_PERIOD 10000

/* Define the buffer size for payload strings */
#define MQTT_MAX_SIZE  50

/* Device Configuration */
String deviceId = "joao.ESP8266.SFP:esp8266_completo";
String authId = "joao.ESP8266.SFP_esp8266_completo";
const char* device_password = "Tartaruga5*";

/* Payload Configuration*/
String ditto_topic = "joao.ESP8266.SFP/esp8266_completo";

/* WiFi Configuration */
const char* ssid = "Zenfone";
const char* password = "12345678";

/* BEGIN SAMPLE CODE */
/* dummy numeric */
long dummy_value = 0;

/* Sample text value */
char msg[MQTT_MAX_SIZE];
/* END SAMPLE CODE */

int volatile bot_estado; //botao
bool volatile esp_estado = false; //Alterei isto
int warm = 0;

/**************************************************************************/
/* Implementation                                                         */
/**************************************************************************/

/* Port on which the MQTT broker is listening */
#if (USE_SECURE_CONNECTION == 1)
    #define MQTT_SERVER_PORT 8883
#else
    #define MQTT_SERVER_PORT 1883
#endif

/* Topic on which the telemetry data is published */
String telemetryTopic = String("telemetry/") + String(tenantId) + String("/");

/* This variables stores the client ID in the MQTT protocol */
String clientId;

/* Timestamp of previous data transmission */
long lastMqttMsg;

/* Setup WiFi mqttClient and MQTT mqttClient */
#if (USE_SECURE_CONNECTION == 1)
    WiFiClientSecure wifiClient;
#else
    WiFiClient wifiClient;
#endif
PubSubClient mqttClient(wifiClient);

/* The information model object */
vorto_private_joaopedro_bastos::ESP8266completo infoModel;
org_eclipse_vorto_types::SensorValue value;

/**************************************************************************/
/* Function to connect to the WiFi network                                */
/**************************************************************************/
void setup_wifi() {

    delay(10);
  
    /* We start by connecting to a WiFi network */
    Serial.print("Connecting to WiFi with SSID: ");
    Serial.println(ssid);
    WiFi.begin(ssid, password);

    /* Wait for succesful connection, hang if there is none? */
    while (WiFi.status() != WL_CONNECTED) {
    	Serial.print(".");
        delay(500);
    }

    randomSeed(micros());

    Serial.println("");
    Serial.println("WiFi connected");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());
    Serial.print("MAC address: ");
    Serial.println(WiFi.macAddress());
}

/**************************************************************************/
/* Function called when data on a subscribed topic arrives                */
/**************************************************************************/
void mqttDataReceived(char* topic, byte* payload, unsigned int length) {
	
    /* BEGIN SAMPLE CODE */
     		 
    if ((char)payload[0] == '1') {		  	    
		Serial.println("MQTT Data sucessfully received"); 
    } else {		  	    
      	Serial.println("No MQTT Data reveived");
    }
    
    /* END SAMPE CODE */
}

/**************************************************************************/
/* Reconnect to MQTT broker in case the connection dropped                */
/**************************************************************************/
void reconnect() {
	String username = String(authId) + "@" + String(tenantId);
    /* Loop while not connected */
    while (!mqttClient.connected()) {		    

        /* If connected to the MQTT broker... */
        
        
        if (mqttClient.connect(clientId.c_str(),username.c_str(),device_password)) {
            /* Attempt to Connect succesfull */		            
            Serial.println("Successfully connected to MQTT Broker");
            /* SAMPLE CODE */
            //String topic = telemetryTopic + "/led";
            //mqttClient.subscribe(topic.c_str());		            
            /* END SAMPLE CODE */
        } else {
    	    /* otherwise wait for 5 seconds before retrying */
    	    Serial.println("Waiting for next attempt to connect to MQTT Broker");
            delay(5000);
        }
    }
}

/**************************************************************************/
/* Functions for publishing data using MQTT					              */
/**************************************************************************/

boolean publishTemperature() {			
		String mqttPayload = infoModel.temperature.serialize(ditto_topic ,deviceId, "temperature");
	
		/* Debug output on console */
		Serial.print("Publishing Payload for temperature: "); 
		Serial.print(mqttPayload);
		Serial.print(" to topic: "); 
		Serial.println(telemetryTopic);
	
		/* Publish all available temperature data to the MQTT broker */
		if(!mqttClient.publish(telemetryTopic.c_str(), mqttPayload.c_str())) {		 	    
			Serial.println("Publish temperature failed, if this happens repeatedly increase MQTT_MAX_PACKET_SIZE in PubSubClient.h");		 	    
			return false;
		} else {		 	    
			return true; 		  	
		}		 
}       	
boolean publishHumidity() {			
		String mqttPayload = infoModel.humidity.serialize(ditto_topic ,deviceId, "humidity");
	
		/* Debug output on console */
		Serial.print("Publishing Payload for humidity: "); 
		Serial.print(mqttPayload);
		Serial.print(" to topic: "); 
		Serial.println(telemetryTopic);
	
		/* Publish all available humidity data to the MQTT broker */
		if(!mqttClient.publish(telemetryTopic.c_str(), mqttPayload.c_str())) {		 	    
			Serial.println("Publish humidity failed, if this happens repeatedly increase MQTT_MAX_PACKET_SIZE in PubSubClient.h");		 	    
			return false;
		} else {		 	    
			return true; 		  	
		}		 
}       	
boolean publishIlluminance() {			
		String mqttPayload = infoModel.illuminance.serialize(ditto_topic ,deviceId, "illuminance");
	
		/* Debug output on console */
		Serial.print("Publishing Payload for illuminance: "); 
		Serial.print(mqttPayload);
		Serial.print(" to topic: "); 
		Serial.println(telemetryTopic);
	
		/* Publish all available illuminance data to the MQTT broker */
		if(!mqttClient.publish(telemetryTopic.c_str(), mqttPayload.c_str())) {		 	    
			Serial.println("Publish illuminance failed, if this happens repeatedly increase MQTT_MAX_PACKET_SIZE in PubSubClient.h");		 	    
			return false;
		} else {		 	    
			return true; 		  	
		}		 
}       	
boolean publishLocalcontrolstate() {			
		String mqttPayload = infoModel.localcontrolstate.serialize(ditto_topic ,deviceId, "localcontrolstate");
	
		/* Debug output on console */
		Serial.print("Publishing Payload for localcontrolstate: "); 
		Serial.print(mqttPayload);
		Serial.print(" to topic: "); 
		Serial.println(telemetryTopic);
	
		/* Publish all available localcontrolstate data to the MQTT broker */
		if(!mqttClient.publish(telemetryTopic.c_str(), mqttPayload.c_str())) {		 	    
			Serial.println("Publish localcontrolstate failed, if this happens repeatedly increase MQTT_MAX_PACKET_SIZE in PubSubClient.h");		 	    
			return false;
		} else {		 	    
			return true; 		  	
		}		 
}

/*uint16_t getTemperature() {
  uint16_t temp = bme.readTemperature();

  return temp;
}

uint16_t getHumidity() {
  uint16_t humid = bme.readHumidity();

  return humid;
}*/

/**************************************************************************/
/* Arduino Setup and Loop Functions							              */
/**************************************************************************/
void setup() {		    
    Serial.begin(115200);
    
    setup_wifi();

    pinMode(LED_AQ, OUTPUT);
    pinMode(LED_Estado, OUTPUT);
    pinMode(LED, OUTPUT);
    //digitalWrite(LED, LOW);
    pinMode(Botao, INPUT);
    attachInterrupt(digitalPinToInterrupt(Botao), IntCallback, RISING);

    int min_humid = 0;
    int max_humid = 100;
    unsigned status;
    
    // default settings
    // (you can also pass in a Wire library object like &Wire2)
    status = bme.begin();  
    if (!status) {
      Serial.println("Could not find a valid BME280 sensor, check wiring, address, sensor ID!");
      while (1);
    }
  
   /* Create a MQTT client ID */
    clientId = deviceId;
    
    Serial.print("Device ID: ");
    Serial.println(clientId);
    
    /* Add the device ID to the telemetry topic as the final element */
    telemetryTopic += deviceId;
  
    /* Configure the MQTT client with the server and callback data */
    mqttClient.setServer(hub_adapter_host, MQTT_SERVER_PORT);
    mqttClient.setCallback(mqttDataReceived);

    #if (USE_SECURE_CONNECTION == 1)
        if (!wifiClient.connect(hub_adapter_host, MQTT_SERVER_PORT)) {
        	Serial.println("Secure connection failed, restart Device");		            
	        ESP.restart();
        } else {
        	Serial.println("Successfully established secure connection to broker");
		}
		
        /*if (!wifiClient.verify(mqttServerFingerprint, hub_adapter_host)) {
            Serial.println("Verification failed, restart Device");	
	        ESP.restart();
        } else {
        	Serial.println("Successfully verified server certificate");
        }*/
    #endif
    
    /*Test MQQT Client*/
    mqttClient.publish("","");

    //Temperature
    infoModel.temperature.setunit("ºC");

    //Humidade
    infoModel.humidity.setminRangeValue(min_humid);
    infoModel.humidity.setmaxRangeValue(max_humid);
    infoModel.humidity.setminMeasuredValue(infoModel.humidity.getmaxRangeValue());
    infoModel.humidity.setsensorUnits("%");

    //Luminosidade
    value.setminMeasured(1024.0);
}

void IntCallback(){
  bot_estado=digitalRead(Botao); //O estado do botão não varia, porquê?

  if(esp_estado==false & bot_estado==1){
    esp_estado=true;
    digitalWrite(LED_Estado, HIGH);
  }  
  else if(esp_estado==true & bot_estado==1){
    esp_estado=false;
    digitalWrite(LED_Estado, LOW);
  }
  else if(esp_estado==true & bot_estado==0){
    esp_estado=true;
    digitalWrite(LED_Estado, HIGH);
  }
  else if(esp_estado==false & bot_estado==0){
    esp_estado=false;
    digitalWrite(LED_Estado, LOW);
  }
  
  infoModel.localcontrolstate.setcurrentState(esp_estado);
  publishLocalcontrolstate();

}

void loop() {		
	/* Check if connection to MQTT broker is still good */
    if (!mqttClient.connected()) {
    	/* Reconnect if not */
        reconnect();
    }
    
    /* Event handling of the MQTT client */
    mqttClient.loop();

    /* Publish the telemetry data periodically */
    long now = millis();
    if (now - lastMqttMsg > MQTT_DATA_PERIOD) {
        
        float temp = bme.readTemperature();

        if(temp<=24){
            digitalWrite(LED_AQ, HIGH);
            warm=1;
          }else if(temp>26){
            digitalWrite(LED_AQ, LOW);
            warm=0;
          }else if(temp>=24 && warm==1){
            digitalWrite(LED_AQ, HIGH);
            warm=1;
          }else if(temp>=24 && warm==0){
            digitalWrite(LED_AQ, LOW);
            warm=0;
          }
        
        float humid = bme.readHumidity();

        float luz = analogRead(A0);
        delay(3);

        luz = (luz/1024.0)*100;
        
        lastMqttMsg = now;
        
        /* SAMPLE CODE */
        dummy_value++;
        snprintf(msg, MQTT_MAX_SIZE - 1, "hello world #%ld", dummy_value);
        
        //Temperatura
        	infoModel.temperature.setvalue(temp);
          
        //Humidade
        	infoModel.humidity.setsensorValue(humid);

        /* minimum value measured since last reboot */
        if (humid < infoModel.humidity.getminMeasuredValue()) { 
          infoModel.humidity.setminMeasuredValue(humid); 
        }; 
        /* maximum value measured since last reboot */ 
        if (humid > infoModel.humidity.getmaxMeasuredValue()) {
          infoModel.humidity.setmaxMeasuredValue(humid);
        };
         
        //Luminosidade
        value.setcurrentMeasured(luz);
          /* minimum value measured since last reboot */
        if (luz < value.getminMeasured()) { 
          value.setminMeasured(luz); }; 
        /* maximum value measured since last reboot */ 
        if (luz > value.getmaxMeasured()) {
             value.setmaxMeasured(luz);
        };
      	infoModel.illuminance.setvalue(value);
        
        //Status Properties
        
        publishTemperature();
        publishHumidity();
        publishIlluminance();
/* END OF SAMPLE CODE */
    }
}
